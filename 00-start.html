<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden;
        }
    </style>
    <title>Joy of Math</title>
</head>
<body>
<canvas id="canvas"></canvas>
<script src="gl-matrix.js"></script>
<script>
const canvas = document.getElementById("canvas");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
const ctx = canvas.getContext("2d");

const { mat3, vec2 } = glMatrix;

const vertices = [
    [-1, 1],
    [0, -1],
    [1, 1]
];

const triangles = new Array(3000).fill().map((_, i) => {
    const rawPosition = [
        randomRange(0, canvas.width),
        randomRange(0, canvas.height)
    ];

    const position = [
        canvas.width / 100 * Math.floor(rawPosition[0] / (canvas.width / 100)),
        canvas.height / 100 * Math.floor(rawPosition[1] / (canvas.height / 100))
    ]

    return {
        position: position,
        positionOffset: [
            0,
            canvas.height
        ],
        size1: randomRange(10, 50),
        size2: randomRange(10, 50),
        rotation: randomRange(Math.PI / 6, Math.PI / 3),
        rotationOffset: randomRange(-Math.PI / 2, Math.PI / 2),
        color: [0, randomRange(0, 255), 0],
        matrix: mat3.create(),
        char: String.fromCharCode(Math.floor(randomRange(0, 65535))),
        cycleMultiplier: Math.floor(randomRange(1, 5)),
    };
});

const camera = {
    position: [0, 0],
    zoom: 1,
    matrix: mat3.create()
};

////////////////////////////
// Render Loop
////////////////////////////

let startTime = performance.now(); 
requestAnimationFrame(function loop() {
    requestAnimationFrame(loop);

    ////////////////////////////
    // Time Since Rendering
    // Started
    ////////////////////////////

    const t = (performance.now() - startTime) * 0.001;
    const osc = Math.sin(t);             // -1 to 1
    const alpha = normalize(-1, 1, osc); //  0 to 1
    // const cycle = t;

    ////////////////////////////
    // Clear the Canvas
    ////////////////////////////

    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = 'white';
    ctx.fillText(`osc:   ${osc.toFixed(2)}`, 10, 15);
    ctx.fillText(`alpha: ${alpha.toFixed(2)}`, 10, 25);
    ctx.fillText(`t: ${t.toFixed(2)}`, 10, 35);

    ////////////////////////////
    // Loop Over All Triangles
    ////////////////////////////

    triangles.forEach(tri => {

        const cycle = t / tri.cycleMultiplier;

        ////////////////////////////
        // Transform Vertices
        ////////////////////////////

        const size = tri.size1; // lerp(tri.size1, tri.size2, alpha);
        const scaleMatrix = mat3.fromScaling(mat3.create(), [size, size]);

        const rotation = tri.rotation; // + osc * tri.rotationOffset;
        const rotationMatrix = mat3.fromRotation(mat3.create(), rotation);

        const positionOffset = vec2.scale([0, 0], tri.positionOffset, cycle);
        const position = vec2.add([0, 0], tri.position, positionOffset);
        position[1] = position[1] % canvas.height;
        const translationMatrix = mat3.fromTranslation(mat3.create(), position);

        mat3.multiply(tri.matrix, rotationMatrix, scaleMatrix);
        mat3.multiply(tri.matrix, translationMatrix, tri.matrix);

        const transformMatrix = mat3.multiply(mat3.create(), camera.matrix, tri.matrix);

        const transformedVertices = vertices.map(v => {
            return vec2.transformMat3([0, 0], v, transformMatrix);
        });

        ////////////////////////////
        // Draw Triangles
        ////////////////////////////

        ctx.fillStyle = `rgb(${tri.color.join(",")})`;
        // ctx.beginPath();
        // ctx.moveTo(...transformedVertices[0]);
        // transformedVertices.slice(1).forEach(v => ctx.lineTo(...v));
        ctx.fillText(tri.char, transformedVertices[0][0], transformedVertices[0][1]);
        ctx.closePath();
        ctx.fill();
    })
});

////////////////////////////
// Utility Functions and
// Event Listeners
////////////////////////////

function randomRange(min, max) {
    return Math.random() * (max - min) + min;
}

function normalize(min, max, value) {
    return (value - min) / (max - min);
}

function lerp(value1, value2, alpha) {
    return value1 * (1 - alpha) + value2 * alpha;
}

function updateCameraMatrix() {
    const centerMatrix = mat3.fromTranslation(mat3.create(), [-canvas.width / 2, -canvas.height / 2]);
    const zoomMatrix = mat3.fromScaling(mat3.create(), [camera.zoom, camera.zoom]);
    const uncenterMatrix = mat3.fromTranslation(mat3.create(), [canvas.width / 2, canvas.height / 2]);
    const translationMatrix = mat3.fromTranslation(mat3.create(), camera.position);

    mat3.multiply(camera.matrix, zoomMatrix, centerMatrix);
    mat3.multiply(camera.matrix, uncenterMatrix, camera.matrix);
    mat3.multiply(camera.matrix, translationMatrix, camera.matrix);
}

let dragging = false;
let lastMouse = [0, 0];
canvas.addEventListener("mousedown", (event) => {
    dragging = true;
    vec2.set(lastMouse, event.clientX, event.clientY);
});

canvas.addEventListener("mousemove", (event) => {
    if (dragging) {
        const mouse = [event.clientX, event.clientY];
        const delta = vec2.subtract([0, 0], mouse, lastMouse);
        vec2.copy(lastMouse, mouse);

        vec2.add(camera.position, camera.position, delta);
        updateCameraMatrix();
    }
});

window.addEventListener("mouseup", (event) => {
    dragging = false;
});

window.addEventListener("wheel", (event) => {
    camera.zoom -= Math.sign(event.deltaY) * 0.01;
    updateCameraMatrix();
});

</script>
</body>
</html>